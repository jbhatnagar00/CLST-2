// src/features/outfits/api/outfits.api.ts
import { apiClient } from '@/shared/services/api/ApiClient';
import type { Outfit, WeeklyPlan, WeatherForecast } from '../types';
import type { PaginatedResponse, PaginationParams } from '@/shared/types';

export const outfitsApi = {
  getOutfits: async (params?: PaginationParams): Promise<PaginatedResponse<Outfit>> => {
    return apiClient.get('/outfits', { params });
  },

  getOutfit: async (id: string): Promise<Outfit> => {
    return apiClient.get(`/outfits/${id}`);
  },

  createOutfit: async (data: Partial<Outfit>): Promise<Outfit> => {
    return apiClient.post('/outfits', data);
  },

  updateOutfit: async (id: string, data: Partial<Outfit>): Promise<Outfit> => {
    return apiClient.patch(`/outfits/${id}`, data);
  },

  deleteOutfit: async (id: string): Promise<void> => {
    return apiClient.delete(`/outfits/${id}`);
  },

  getWeeklyPlan: async (weekStartDate: string): Promise<WeeklyPlan> => {
    return apiClient.get('/outfits/weekly-plan', { params: { weekStartDate } });
  },

  updateWeeklyPlan: async (data: Partial<WeeklyPlan>): Promise<WeeklyPlan> => {
    return apiClient.post('/outfits/weekly-plan', data);
  },

  getWeatherForecast: async (date: string): Promise<WeatherForecast> => {
    return apiClient.get('/weather/forecast', { params: { date } });
  },

  getOutfitSuggestions: async (weather: WeatherForecast, occasion: string): Promise<Outfit[]> => {
    return apiClient.post('/outfits/suggestions', { weather, occasion });
  },

  markOutfitWorn: async (outfitId: string): Promise<void> => {
    return apiClient.post(`/outfits/${outfitId}/wear`);
  },
};

// src/features/outfits/stores/outfit.store.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import type { Outfit, WeeklyPlan, DailyPlan } from '../types';
import type { ClothingItem } from '@/features/closet/types';
import { outfitsApi } from '../api/outfits.api';

interface OutfitState {
  // State
  outfits: Outfit[];
  currentOutfit: Outfit | null;
  weeklyPlan: WeeklyPlan | null;
  isLoading: boolean;
  error: string | null;

  // Outfit builder
  builderItems: Map<string, ClothingItem>; // category -> item
  builderName: string;
  builderOccasions: string[];
  builderSeasons: string[];

  // Actions
  fetchOutfits: () => Promise<void>;
  fetchOutfit: (id: string) => Promise<void>;
  createOutfit: (outfit: Partial<Outfit>) => Promise<void>;
  updateOutfit: (id: string, updates: Partial<Outfit>) => Promise<void>;
  deleteOutfit: (id: string) => Promise<void>;

  // Builder actions
  addToBuilder: (item: ClothingItem) => void;
  removeFromBuilder: (category: string) => void;
  clearBuilder: () => void;
  setBuilderName: (name: string) => void;
  setBuilderOccasions: (occasions: string[]) => void;
  setBuilderSeasons: (seasons: string[]) => void;
  saveBuilderAsOutfit: () => Promise<void>;

  // Weekly plan actions
  fetchWeeklyPlan: (weekStartDate: string) => Promise<void>;
  updateDailyPlan: (date: string, plan: Partial<DailyPlan>) => void;
  addOutfitToPlan: (date: string, outfitId: string, time: string, occasion: string) => void;
  removeOutfitFromPlan: (date: string, outfitId: string) => void;
  saveWeeklyPlan: () => Promise<void>;
}

export const useOutfitStore = create<OutfitState>()(
  devtools(
    immer((set, get) => ({
      // Initial State
      outfits: [],
      currentOutfit: null,
      weeklyPlan: null,
      isLoading: false,
      error: null,
      builderItems: new Map(),
      builderName: '',
      builderOccasions: [],
      builderSeasons: [],

      // Actions
      fetchOutfits: async () => {
        set((state) => {
          state.isLoading = true;
          state.error = null;
        });

        try {
          const response = await outfitsApi.getOutfits({ page: 1, limit: 100 });
          set((state) => {
            state.outfits = response.data;
            state.isLoading = false;
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to fetch outfits';
            state.isLoading = false;
          });
        }
      },

      fetchOutfit: async (id) => {
        set((state) => {
          state.isLoading = true;
          state.error = null;
        });

        try {
          const outfit = await outfitsApi.getOutfit(id);
          set((state) => {
            state.currentOutfit = outfit;
            state.isLoading = false;
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to fetch outfit';
            state.isLoading = false;
          });
        }
      },

      createOutfit: async (outfit) => {
        try {
          const newOutfit = await outfitsApi.createOutfit(outfit);
          set((state) => {
            state.outfits.push(newOutfit);
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to create outfit';
          });
          throw error;
        }
      },

      updateOutfit: async (id, updates) => {
        try {
          const updatedOutfit = await outfitsApi.updateOutfit(id, updates);
          set((state) => {
            const index = state.outfits.findIndex(o => o.id === id);
            if (index !== -1) {
              state.outfits[index] = updatedOutfit;
            }
            if (state.currentOutfit?.id === id) {
              state.currentOutfit = updatedOutfit;
            }
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to update outfit';
          });
          throw error;
        }
      },

      deleteOutfit: async (id) => {
        try {
          await outfitsApi.deleteOutfit(id);
          set((state) => {
            state.outfits = state.outfits.filter(o => o.id !== id);
            if (state.currentOutfit?.id === id) {
              state.currentOutfit = null;
            }
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to delete outfit';
          });
          throw error;
        }
      },

      // Builder actions
      addToBuilder: (item) => {
        set((state) => {
          state.builderItems.set(item.category, item);
        });
      },

      removeFromBuilder: (category) => {
        set((state) => {
          state.builderItems.delete(category);
        });
      },

      clearBuilder: () => {
        set((state) => {
          state.builderItems.clear();
          state.builderName = '';
          state.builderOccasions = [];
          state.builderSeasons = [];
        });
      },

      setBuilderName: (name) => {
        set((state) => {
          state.builderName = name;
        });
      },

      setBuilderOccasions: (occasions) => {
        set((state) => {
          state.builderOccasions = occasions;
        });
      },

      setBuilderSeasons: (seasons) => {
        set((state) => {
          state.builderSeasons = seasons;
        });
      },

      saveBuilderAsOutfit: async () => {
        const { builderItems, builderName, builderOccasions, builderSeasons } = get();
        
        if (builderItems.size === 0) {
          throw new Error('No items in outfit');
        }

        const outfitData = {
          name: builderName || 'Untitled Outfit',
          items: Array.from(builderItems.values()).map(item => ({
            itemId: item.id,
            category: item.category,
          })),
          occasions: builderOccasions,
          seasons: builderSeasons,
        };

        await get().createOutfit(outfitData);
        get().clearBuilder();
      },

      // Weekly plan actions
      fetchWeeklyPlan: async (weekStartDate) => {
        set((state) => {
          state.isLoading = true;
          state.error = null;
        });

        try {
          const plan = await outfitsApi.getWeeklyPlan(weekStartDate);
          set((state) => {
            state.weeklyPlan = plan;
            state.isLoading = false;
          });
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to fetch weekly plan';
            state.isLoading = false;
          });
        }
      },

      updateDailyPlan: (date, plan) => {
        set((state) => {
          if (!state.weeklyPlan) return;
          
          const dayIndex = state.weeklyPlan.plans.findIndex(p => p.date === date);
          if (dayIndex !== -1) {
            Object.assign(state.weeklyPlan.plans[dayIndex], plan);
          }
        });
      },

      addOutfitToPlan: (date, outfitId, time, occasion) => {
        set((state) => {
          if (!state.weeklyPlan) return;
          
          const dayIndex = state.weeklyPlan.plans.findIndex(p => p.date === date);
          if (dayIndex !== -1) {
            state.weeklyPlan.plans[dayIndex].outfits.push({
              outfitId,
              time: time as any,
              occasion: occasion as any,
              isCompleted: false,
            });
          }
        });
      },

      removeOutfitFromPlan: (date, outfitId) => {
        set((state) => {
          if (!state.weeklyPlan) return;
          
          const dayIndex = state.weeklyPlan.plans.findIndex(p => p.date === date);
          if (dayIndex !== -1) {
            state.weeklyPlan.plans[dayIndex].outfits = 
              state.weeklyPlan.plans[dayIndex].outfits.filter(o => o.outfitId !== outfitId);
          }
        });
      },

      saveWeeklyPlan: async () => {
        const { weeklyPlan } = get();
        if (!weeklyPlan) return;

        try {
          await outfitsApi.updateWeeklyPlan(weeklyPlan);
        } catch (error: any) {
          set((state) => {
            state.error = error.message || 'Failed to save weekly plan';
          });
          throw error;
        }
      },
    }))
  )
);

// src/features/outfits/components/OutfitBuilder/OutfitBuilder.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { Card } from '@/shared/components/ui/Card';
import { Button } from '@/shared/components/ui/Button';
import { Input } from '@/shared/components/ui/Input';
import { closetApi } from '@/features/closet/api/closet.api';
import { useOutfitStore } from '../../stores/outfit.store';
import { ItemSelector } from '../ItemSelector';
import { OutfitPreview } from '../OutfitPreview';
import { toast } from '@/shared/components/feedback/Toast';
import type { ClothingCategory, Season, Occasion } from '@/features/closet/types';

const SEASONS: Season[] = ['spring', 'summer', 'fall', 'winter', 'all-season'];
const OCCASIONS: Occasion[] = ['casual', 'work', 'formal', 'party', 'sport', 'beach', 'date', 'other'];

export const OutfitBuilder: React.FC = () => {
  const navigate = useNavigate();
  const {
    builderItems,
    builderName,
    builderOccasions,
    builderSeasons,
    addToBuilder,
    removeFromBuilder,
    setBuilderName,
    setBuilderOccasions,
    setBuilderSeasons,
    saveBuilderAsOutfit,
    clearBuilder,
  } = useOutfitStore();

  const [activeCategory, setActiveCategory] = useState<ClothingCategory>('tops');
  const [isSaving, setIsSaving] = useState(false);

  const { data: closetItems } = useQuery({
    queryKey: ['closet-items-builder'],
    queryFn: () => closetApi.getItems({ page: 1, limit: 1000 }),
  });

  const handleSave = async () => {
    if (builderItems.size === 0) {
      toast.show({ type: 'error', message: 'Add at least one item to your outfit' });
      return;
    }

    setIsSaving(true);
    try {
      await saveBuilderAsOutfit();
      toast.show({ type: 'success', message: 'Outfit saved!' });
      navigate('/outfits');
    } catch (error) {
      toast.show({ type: 'error', message: 'Failed to save outfit' });
    } finally {
      setIsSaving(false);
    }
  };

  const categories: ClothingCategory[] = [
    'tops', 'bottoms', 'dresses', 'outerwear', 
    'shoes', 'accessories', 'underwear', 'activewear', 
    'swimwear', 'other'
  ];

  const itemsByCategory = closetItems?.data.reduce((acc, item) => {
    if (!acc[item.category]) {
      acc[item.category] = [];
    }
    acc[item.category].push(item);
    return acc;
  }, {} as Record<ClothingCategory, typeof closetItems.data>);

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
      {/* Item Selection */}
      <div className="lg:col-span-2 space-y-6">
        <Card variant="outlined" padding="lg">
          <h2 className="text-xl font-semibold mb-4">Build Your Outfit</h2>
          
          {/* Category Tabs */}
          <div className="flex flex-wrap gap-2 mb-6">
            {categories.map((category) => (
              <button
                key={category}
                onClick={() => setActiveCategory(category)}
                className={`
                  px-4 py-2 rounded-lg border-2 transition-colors
                  ${activeCategory === category 
                    ? 'bg-black text-white border-black' 
                    : 'bg-white text-black border-black hover:bg-gray-100'
                  }
                `}
              >
                {category.charAt(0).toUpperCase() + category.slice(1)}
                {builderItems.has(category) && ' ‚úì'}
              </button>
            ))}
          </div>

          {/* Items Grid */}
          <ItemSelector
            items={itemsByCategory?.[activeCategory] || []}
            selectedItem={builderItems.get(activeCategory)}
            onSelectItem={(item) => {
              if (item) {
                addToBuilder(item);
              } else {
                removeFromBuilder(activeCategory);
              }
            }}
            category={activeCategory}
          />
        </Card>

        {/* Outfit Details */}
        <Card variant="outlined" padding="lg">
          <h3 className="text-lg font-semibold mb-4">Outfit Details</h3>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2">
                Outfit Name
              </label>
              <Input
                value={builderName}
                onChange={(e) => setBuilderName(e.target.value)}
                placeholder="My Awesome Outfit"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">
                Seasons
              </label>
              <div className="flex flex-wrap gap-2">
                {SEASONS.map((season) => (
                  <label key={season} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={builderSeasons.includes(season)}
                      onChange={(e) => {
                        if (e.target.checked) {
                          setBuilderSeasons([...builderSeasons, season]);
                        } else {
                          setBuilderSeasons(builderSeasons.filter(s => s !== season));
                        }
                      }}
                      className="w-4 h-4 border-2 border-black rounded mr-2"
                    />
                    <span className="text-sm">
                      {season.charAt(0).toUpperCase() + season.slice(1)}
                    </span>
                  </label>
                ))}
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">
                Occasions
              </label>
              <div className="flex flex-wrap gap-2">
                {OCCASIONS.map((occasion) => (
                  <label key={occasion} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={builderOccasions.includes(occasion)}
                      onChange={(e) => {
                        if (e.target.checked) {
                          setBuilderOccasions([...builderOccasions, occasion]);
                        } else {
                          setBuilderOccasions(builderOccasions.filter(o => o !== occasion));
                        }
                      }}
                      className="w-4 h-4 border-2 border-black rounded mr-2"
                    />
                    <span className="text-sm">
                      {occasion.charAt(0).toUpperCase() + occasion.slice(1)}
                    </span>
                  </label>
                ))}
              </div>
            </div>
          </div>
        </Card>
      </div>

      {/* Outfit Preview */}
      <div className="space-y-6">
        <OutfitPreview
          items={Array.from(builderItems.values())}
          name={builderName || 'Untitled Outfit'}
        />

        <div className="flex flex-col space-y-2">
          <Button
            variant="primary"
            size="lg"
            onClick={handleSave}
            isLoading={isSaving}
            disabled={builderItems.size === 0}
          >
            Save Outfit
          </Button>
          <Button
            variant="ghost"
            onClick={() => {
              clearBuilder();
              navigate('/outfits');
            }}
          >
            Cancel
          </Button>
        </div>
      </div>
    </div>
  );
};

// src/features/outfits/components/ItemSelector/ItemSelector.tsx
import React from 'react';
import type { ClothingItem } from '@/features/closet/types';

interface ItemSelectorProps {
  items: ClothingItem[];
  selectedItem?: ClothingItem;
  onSelectItem: (item: ClothingItem | null) => void;
  category: string;
}

export const ItemSelector: React.FC<ItemSelectorProps> = ({
  items,
  selectedItem,
  onSelectItem,
  category,
}) => {
  if (items.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        No {category} in your closet
      </div>
    );
  }

  return (
    <div className="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3">
      {items.map((item) => {
        const isSelected = selectedItem?.id === item.id;
        const primaryImage = item.images.find(img => img.isPrimary) || item.images[0];
        
        return (
          <button
            key={item.id}
            onClick={() => onSelectItem(isSelected ? null : item)}
            className={`
              relative aspect-square rounded-lg overflow-hidden border-2 transition-all
              ${isSelected 
                ? 'border-black ring-2 ring-offset-2 ring-black' 
                : 'border-gray-300 hover:border-gray-400'
              }
            `}
          >
            {primaryImage ? (
              <img
                src={primaryImage.thumbnailUrl || primaryImage.url}
                alt={item.name}
                className="w-full h-full object-cover"
              />
            ) : (
              <div className="w-full h-full bg-gray-200 flex items-center justify-center">
                <span className="text-2xl">üëï</span>
              </div>
            )}
            
            {isSelected && (
              <div className="absolute inset-0 bg-black bg-opacity-20 flex items-center justify-center">
                <span className="text-white text-2xl">‚úì</span>
              </div>
            )}
            
            <div className="absolute bottom-0 left-0 right-0 bg-white bg-opacity-90 p-1">
              <p className="text-xs truncate">{item.name}</p>
            </div>
          </button>
        );
      })}
    </div>
  );
};

// src/features/outfits/components/OutfitPreview/OutfitPreview.tsx
import React from 'react';
import { Card } from '@/shared/components/ui/Card';
import type { ClothingItem } from '@/features/closet/types';

interface OutfitPreviewProps {
  items: ClothingItem[];
  name: string;
}

export const OutfitPreview: React.FC<OutfitPreviewProps> = ({ items, name }) => {
  const getItemByCategory = (category: string) => 
    items.find(item => item.category === category);

  const renderItemSlot = (category: string, label: string) => {
    const item = getItemByCategory(category);
    const image = item?.images.find(img => img.isPrimary) || item?.images[0];

    return (
      <div className="text-center">
        <div className="w-24 h-24 mx-auto mb-2 rounded-lg border-2 border-dashed border-gray-300 overflow-hidden">
          {image ? (
            <img
              src={image.thumbnailUrl || image.url}
              alt={item.name}
              className="w-full h-full object-cover"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center text-gray-400">
              <span className="text-2xl">+</span>
            </div>
          )}
        </div>
        <p className="text-xs text-gray-600">{label}</p>
      </div>
    );
  };

  return (
    <Card variant="outlined" padding="lg">
      <h3 className="text-lg font-semibold mb-4">{name}</h3>
      
      <div className="space-y-4">
        {/* Upper body */}
        <div className="flex justify-center space-x-4">
          {renderItemSlot('outerwear', 'Outerwear')}
          {renderItemSlot('tops', 'Top')}
        </div>

        {/* Middle */}
        <div className="flex justify-center space-x-4">
          {renderItemSlot('bottoms', 'Bottom')}
          {renderItemSlot('dresses', 'Dress')}
        </div>

        {/* Lower body */}
        <div className="flex justify-center">
          {renderItemSlot('shoes', 'Shoes')}
        </div>

        {/* Accessories */}
        <div className="flex justify-center">
          {renderItemSlot('accessories', 'Accessories')}
        </div>
      </div>

      <div className="mt-4 pt-4 border-t">
        <p className="text-sm text-gray-600">
          {items.length} items selected
        </p>
      </div>
    </Card>
  );
};

// src/features/outfits/components/WeeklyCalendar/WeeklyCalendar.tsx
import React, { useState, useEffect } from 'react';
import { Card } from '@/shared/components/ui/Card';
import { Button } from '@/shared/components/ui/Button';
import { useOutfitStore } from '../../stores/outfit.store';
import { outfitsApi } from '../../api/outfits.api';
import { formatDate } from '@/shared/utils/helpers';
import type { DailyPlan, WeatherForecast } from '../../types';

interface WeeklyCalendarProps {
  weekStartDate: Date;
  onDateSelect: (date: Date) => void;
}

export const WeeklyCalendar: React.FC<WeeklyCalendarProps> = ({
  weekStartDate,
  onDateSelect,
}) => {
  const { weeklyPlan, fetchWeeklyPlan, saveWeeklyPlan } = useOutfitStore();
  const [weather, setWeather] = useState<Record<string, WeatherForecast>>({});
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    fetchWeeklyPlan(weekStartDate.toISOString());
    fetchWeatherForWeek();
  }, [weekStartDate]);

  const fetchWeatherForWeek = async () => {
    const weatherData: Record<string, WeatherForecast> = {};
    
    for (let i = 0; i < 7; i++) {
      const date = new Date(weekStartDate);
      date.setDate(date.getDate() + i);
      
      try {
        const forecast = await outfitsApi.getWeatherForecast(date.toISOString());
        weatherData[date.toISOString().split('T')[0]] = forecast;
      } catch (error) {
        console.error('Failed to fetch weather for', date);
      }
    }
    
    setWeather(weatherData);
  };

  const handleSave = async () => {
    setIsSaving(true);
    try {
      await saveWeeklyPlan();
      toast.show({ type: 'success', message: 'Weekly plan saved!' });
    } catch (error) {
      toast.show({ type: 'error', message: 'Failed to save weekly plan' });
    } finally {
      setIsSaving(false);
    }
  };

  const getDaysOfWeek = () => {
    const days = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(weekStartDate);
      date.setDate(date.getDate() + i);
      days.push(date);
    }
    return days;
  };

  const getWeatherIcon = (condition?: string) => {
    const icons: Record<string, string> = {
      sunny: '‚òÄÔ∏è',
      cloudy: '‚òÅÔ∏è',
      rainy: 'üåßÔ∏è',
      snowy: '‚ùÑÔ∏è',
      windy: 'üí®',
    };
    return icons[condition || ''] || 'üå§Ô∏è';
  };

  return (
    <div className="space-y-4">
      <div className="grid grid-cols-7 gap-2">
        {getDaysOfWeek().map((date) => {
          const dateStr = date.toISOString().split('T')[0];
          const dayPlan = weeklyPlan?.plans.find(p => p.date.startsWith(dateStr));
          const dayWeather = weather[dateStr];
          
          return (
            <Card
              key={dateStr}
              variant="outlined"
              className="cursor-pointer hover:border-black transition-colors"
              onClick={() => onDateSelect(date)}
            >
              <div className="p-3 text-center">
                <p className="text-xs text-gray-600">
                  {date.toLocaleDateString('en-US', { weekday: 'short' })}
                </p>
                <p className="text-lg font-semibold">
                  {date.getDate()}
                </p>
                
                {dayWeather && (
                  <div className="mt-2">
                    <p className="text-2xl">{getWeatherIcon(dayWeather.condition)}</p>
                    <p className="text-xs text-gray-600">
                      {dayWeather.temp.min}¬∞ - {dayWeather.temp.max}¬∞
                    </p>
                  </div>
                )}
                
                {dayPlan && dayPlan.outfits.length > 0 && (
                  <div className="mt-2">
                    <p className="text-xs font-medium">
                      {dayPlan.outfits.length} outfit{dayPlan.outfits.length > 1 ? 's' : ''}
                    </p>
                  </div>
                )}
              </div>
            </Card>
          );
        })}
      </div>

      <div className="flex justify-end">
        <Button
          variant="primary"
          onClick={handleSave}
          isLoading={isSaving}
          disabled={!weeklyPlan}
        >
          Save Weekly Plan
        </Button>
      </div>
    </div>
  );
};

// src/features/outfits/pages/CreateOutfitPage.tsx
import React from 'react';
import { OutfitBuilder } from '../components/OutfitBuilder';

const CreateOutfitPage: React.FC = () => {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">Create New Outfit</h1>
        <p className="text-gray-600">
          Mix and match items from your closet to create the perfect outfit
        </p>
      </div>
      
      <OutfitBuilder />
    </div>
  );
};

export default CreateOutfitPage;

// src/features/outfits/pages/WeeklyPlanPage.tsx
import React, { useState } from 'react';
import { WeeklyCalendar } from '../components/WeeklyCalendar';
import { DayPlanModal } from '../components/DayPlanModal';
import { Button } from '@/shared/components/ui/Button';

const WeeklyPlanPage: React.FC = () => {
  const [currentWeek, setCurrentWeek] = useState(() => {
    const today = new Date();
    const monday = new Date(today);
    monday.setDate(today.getDate() - today.getDay() + 1);
    return monday;
  });
  
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);

  const navigateWeek = (direction: number) => {
    const newWeek = new Date(currentWeek);
    newWeek.setDate(newWeek.getDate() + (direction * 7));
    setCurrentWeek(newWeek);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">Weekly Outfit Plan</h1>
        <p className="text-gray-600">
          Plan your outfits for the week based on weather and activities
        </p>
      </div>

      <div className="mb-6 flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <Button
            variant="ghost"
            onClick={() => navigateWeek(-1)}
            aria-label="Previous week"
          >
            ‚Üê
          </Button>
          <h2 className="text-xl font-semibold">
            Week of {currentWeek.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}
          </h2>
          <Button
            variant="ghost"
            onClick={() => navigateWeek(1)}
            aria-label="Next week"
          >
            ‚Üí
          </Button>
        </div>
        
        <Button
          variant="secondary"
          onClick={() => setCurrentWeek(new Date())}
        >
          Today
        </Button>
      </div>

      <WeeklyCalendar
        weekStartDate={currentWeek}
        onDateSelect={setSelectedDate}
      />

      {selectedDate && (
        <DayPlanModal
          date={selectedDate}
          onClose={() => setSelectedDate(null)}
        />
      )}
    </div>
  );
};

export default WeeklyPlanPage;
